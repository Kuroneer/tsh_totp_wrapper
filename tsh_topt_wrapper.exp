#!/usr/bin/expect -f

# ENV VARS:
#  TSHWRAPPER_SECRET_PATH: Path to the secret file
#  TSHWRAPPER_TSH_PATH: Path to tsh runnable
#  TSHWRAPPER_CYPHER: Cypher to use to read the secret file
#  TSHWRAPPER_OPENSSL_MD: Message digestion algorithm to generate key from password
#  TSHWRAPPER_SILENT: If this script should report to the user


# Vars defaults
if [info exists env(USER)] {
    set secret_path /home/$env(USER)/.tsh_otp_secret.aes
} else {
    set secret_path .tsh_otp_secret.aes;
}
set tsh_path tsh
set cypher aes-256-cbc;
set openssl_md sha256
set silent 0

# Check env vars for overrides
if [info exists env(TSHWRAPPER_SECRET_PATH)] {
    set secret_path $env(TSHWRAPPER_SECRET_PATH);
}
if [info exists env(TSHWRAPPER_TSH_PATH)] {
    set tsh_path $env(TSHWRAPPER_TSH_PATH);
}
if [info exists env(TSHWRAPPER_CYPHER)] {
    set cypher $env(TSHWRAPPER_CYPHER);
}
if [info exists env(TSHWRAPPER_OPENSSL_MD)] {
    set openssl_md $env(TSHWRAPPER_OPENSSL_MD);
}
if [info exists env(TSHWRAPPER_SILENT)] {
    set silent $env(TSHWRAPPER_SILENT);
}
##############################


proc report { message { override_silent 0 } } {
    global silent;
    if {$override_silent || !$silent} {
        send_user $message;
    }
}

proc extract_from_uri { uri key } {
    set success [regexp "otpauth:.*$key=\(\[^&\]*\)" $uri _unused match];
    if { $success } {
        return $match;
    } else {
        return "";
    }
}

proc base32_bindecode { base32_string } {
    set chan [open "|base32 -d" r+];
    fconfigure $chan -translation binary -encoding binary;
    puts -nonewline $chan $base32_string;
    flush $chan;
    chan close $chan write;
    set binary_data [read $chan];
    close $chan;
    return $binary_data;
}

proc get_otp { secret period digits } {
    # Decode secret in base32 to hex
    binary scan [base32_bindecode $secret] H* hex_secret;

    # Get time offset as binary
    set now_binary [binary format W [expr [clock seconds] / $period]];

    # Have openssl calculate the mac
    set chan [open "|openssl dgst -sha1 -mac HMAC -macopt hexkey:$hex_secret" r+];
    fconfigure $chan -translation binary -encoding binary;
    puts -nonewline $chan $now_binary;
    flush $chan;
    chan close $chan write;
    regexp {^.*= ([0-9a-z]*)} [read $chan] _unused mac;
    close $chan;

    # Get last 4 bits of mac as offset
    scan [string index $mac end] %x byte_offset;

    # Dynamic truncate and turn into number (need to set the first bit to 0
    scan [string range $mac [expr $byte_offset * 2] [expr $byte_offset * 2 + 7]] %x dec_mac_truncated;
    set dec_mac_truncated [expr $dec_mac_truncated & 0x7FFFFFFF];
    set otp [string range [format "%0*d" $digits $dec_mac_truncated] [expr [string length $dec_mac_truncated] - $digits] end];
    return $otp;
}


report "<TSH TOTP Wrapper>\n";

set arguments [lrange $argv 0 end];

set timeout 60
spawn -noecho $tsh_path {*}$arguments
set tsh_id $spawn_id;
set tsh_pty $spawn_out(slave,name)
expect {
    -i $tsh_id -re "^Enter password for Teleport user .*:" {
        stty -echo;
        report "<Reading the password>\n";
        expect_user -re "(.*)\n";
        report "<Captured the password>\n";
        set pass $expect_out(1,string);

        if { $pass eq "" } {
            report "<The password is empty, bye!>\n";
            exit;
        }

        log_user 0;
        if { [file exists $secret_path] } {
            spawn -noecho openssl $cypher -d -in $secret_path -md $openssl_md;
            set openssl_id $spawn_id;
            expect {
                -i $openssl_id "^enter $cypher decryption password:" {
                    report "<Using the captured password to open $secret_path>\n";
                    send -i $openssl_id "$pass\r";
                    exp_continue;
                }
                -i $openssl_id eof {
                    set info $expect_out(buffer);
                    report "<Captured the secret>\n";
                }
            }
            lassign [wait -i $openssl_id] _pid _spawnid os_error_flag exit_code
                if { $os_error_flag || $exit_code} {
                    report "<The secret was badly decrypted, check $> openssl $cypher -d -in $secret_path -md $openssl_md, bye!>\n" 1;
                    exit;
                }

            set info [string trimright $info \r\n];
            set info [string trimleft $info \r\n];
            set digits [extract_from_uri $info "digits"];
            if { $digits eq "" } {
                set digits 6;
            }
            set period [extract_from_uri $info "period"];
            if { $period eq "" } {
                set period 30;
            }
            set secret [extract_from_uri $info "secret"];
            if { $secret eq "" } {
                report "<Using whole $secret_path as secret>\n";
                set secret $info;
            }
            stty echo ;

            if { $secret eq "" } {
                report "<The secret is empty, check $secret_path and password, bye!>\n" 1;
                exit;
            }
            set otp [get_otp $secret $period $digits];
        }

        send -i $tsh_id "$pass\r";
        log_user 1;

        expect -i $tsh_id "Enter your OTP token:";
        if { ![info exists otp] } {
            report "<Reading the OTP token>\n";
            expect_user -re "(.*)\n";
            report "<Captured the OTP token>\n";
            set otp $expect_out(1,string);
        }
        send -i $tsh_id "$otp\r";
        expect -i $tsh_id "$otp\r";
    }
    -i $tsh_id -re ".";
}

# Propagate window size changes to tsh
trap {
    set XZ [stty rows   ];
    set YZ [stty columns];
    stty rows $XZ columns $YZ < $tsh_pty;
} WINCH

# Workaround to try to handle bad line wrappping
set YZ [stty columns];
set XZ [stty rows   ];
set XZ2 [expr $XZ +1];
stty rows $XZ2 columns $YZ < $tsh_pty; # Does not work 100% percent of times, but nearly enough
# End of workaround

catch { interact -i $tsh_id } err

