#!/usr/bin/expect -f

# ENV VARS:
#  TSHWRAPPER_SECRET_PATH: Path to the secret file
#  TSHWRAPPER_TSH_PATH: Path to tsh runnable
#  TSHWRAPPER_CYPHER: Cypher to use to read the secret file
#  TSHWRAPPER_OPENSSL_MD: Message digestion algorithm to generate key from password
#  TSHWRAPPER_SILENT: If this script should report to the user


# Vars defaults
if [info exists env(USER)] {
    set secret_path /home/$env(USER)/.tsh_otp_secret.aes
} else {
    set secret_path .tsh_otp_secret.aes;
}
set tsh_path tsh
set cypher aes-256-cbc;
set openssl_md sha256
set silent 0

# Check env vars for overrides
if [info exists env(TSHWRAPPER_SECRET_PATH)] {
    set secret_path $env(TSHWRAPPER_SECRET_PATH);
}
if [info exists env(TSHWRAPPER_TSH_PATH)] {
    set tsh_path $env(TSHWRAPPER_TSH_PATH);
}
if [info exists env(TSHWRAPPER_CYPHER)] {
    set cypher $env(TSHWRAPPER_CYPHER);
}
if [info exists env(TSHWRAPPER_OPENSSL_MD)] {
    set openssl_md $env(TSHWRAPPER_OPENSSL_MD);
}
if [info exists env(TSHWRAPPER_SILENT)] {
    set silent $env(TSHWRAPPER_SILENT);
}
##############################


proc report { message { override_silent 0 } } {
    global silent;
    if {$override_silent || !$silent} {
        send_user $message;
    }
}

proc extract_from_uri { uri key } {
    set success [regexp "otpauth:.*$key=\(\[^&\]*\)" $uri _unused match];
    if { $success } {
        return $match;
    } else {
        return "";
    }
}

proc base32_bindecode { base32_string } {
    set chan [open "|base32 -d" r+];
    fconfigure $chan -translation binary -encoding binary;
    puts -nonewline $chan $base32_string;
    flush $chan;
    chan close $chan write;
    set binary_data [read $chan];
    close $chan;
    return $binary_data;
}

proc get_otp { secret period digits } {
    # Decode secret in base32 to hex
    binary scan [base32_bindecode $secret] H* hex_secret;

    # Get time offset as binary
    set now_binary [binary format W [expr [clock seconds] / $period]];

    # Have openssl calculate the mac
    set chan [open "|openssl dgst -sha1 -mac HMAC -macopt hexkey:$hex_secret" r+];
    fconfigure $chan -translation binary -encoding binary;
    puts -nonewline $chan $now_binary;
    flush $chan;
    chan close $chan write;
    regexp {^.*= ([0-9a-z]*)} [read $chan] _unused mac;
    close $chan;

    # Get last 4 bits of mac as offset
    scan [string index $mac end] %x byte_offset;

    # Dynamic truncate and turn into number (need to set the first bit to 0
    scan [string range $mac [expr $byte_offset * 2] [expr $byte_offset * 2 + 7]] %x dec_mac_truncated;
    set dec_mac_truncated [expr $dec_mac_truncated & 0x7FFFFFFF];
    set otp [string range [format "%0*d" $digits $dec_mac_truncated] [expr [string length $dec_mac_truncated] - $digits] end];
    return $otp;
}


report "<TSH TOTP Wrapper>\n";

set arguments [lrange $argv 0 end];

set timeout 60
spawn -noecho $tsh_path {*}$arguments
set tsh_id $spawn_id;
expect {
    -i $tsh_id -re "^Enter password for Teleport user .*:" {
        stty -echo;
        report "<Reading the password>\n";
        expect_user -re "(.*)\n";
        report "<Captured the password>\n";
        set pass $expect_out(1,string);

        if { $pass eq "" } {
            report "<The password is empty, bye!>\n";
            exit;
        }

        log_user 0;
        spawn -noecho openssl $cypher -d -in $secret_path -md $openssl_md;
        set openssl_id $spawn_id;
        expect {
            -i $openssl_id "^enter $cypher decryption password:" {
                report "<Using the captured password to open $secret_path>\n";
                send -i $openssl_id "$pass\r";
                exp_continue;
            }
            -i $openssl_id eof {
                set info $expect_out(buffer);
                report "<Captured the secret>\n";
            }
        }
        lassign [wait -i $openssl_id] _pid _spawnid os_error_flag exit_code
        if { $os_error_flag || $exit_code} {
            report "<The secret was badly decrypted, check $> openssl $cypher -d -in $secret_path -md $openssl_md, bye!>\n" 1;
            exit;
        }

        set info [string trimright $info \r\n];
        set info [string trimleft $info \r\n];
        set digits [extract_from_uri $info "digits"];
        if { $digits eq "" } {
            set digits 6;
        }
        set period [extract_from_uri $info "period"];
        if { $period eq "" } {
            set period 30;
        }
        set secret [extract_from_uri $info "secret"];
        if { $secret eq "" } {
            report "<Using whole $secret_path as secret>\n";
            set secret $info;
        }
        stty echo ;

        if { $secret eq "" } {
            report "<The secret is empty, check $secret_path and password, bye!>\n" 1;
            exit;
        }

        send -i $tsh_id "$pass\r";
        log_user 1;

        expect -i $tsh_id "Enter your OTP token:"
        set otp [get_otp $secret $period $digits];
        send -i $tsh_id "$otp\r";
    }
    -i $tsh_id -re "."
}

interact -i $tsh_id

